[[{"l":"Welcome","p":["Welcome to the Avvy Domains Technical Documentation.","Our goal here is to educate you, the integrator, on how Avvy Domains functions from a technical perspective and how it can be used in your project.","Our Getting Started guide goes over some common use-cases for the project and how you might want to approach your integration."]}],[{"l":"Getting Started","p":["The most common integration use-cases for Avvy Domains are:","Forward Resolution, where we take a .avax name and get a value like an 0x address. This can be useful for scenarios like improving the UX for transferring funds between wallets.","Reverse Resolution, where we take a value like an 0x address and find the associated .avax name. This can be useful for adding identity to applications, making it easier for users to read information.","In most cases, integrators will want to use one of our provided Client Libraries to handle the complexities of the Avvy Domains system. Each"]}],[{"l":"Name Hashing","p":["Names are identified by their hash on-chain. Publishing the preimage of the hash is optional.","A detailed explanation of the motivations behind our hashing mechanism is available in the blog post Privacy Mechanisms for Name Registrations.","We highly recommend using our client libraries to handle operations related to hashing.","Names must be in lower case before starting this process.","We use the Circom implementation of the Poseidon hash function, initialized with three inputs.","Given a name that consists of n labels, we perform n rounds of Poseidon where the first input is the output hash from the previous round (or 0 for the first round) and the second & third inputs are derived from the current label. We refer to the second & third inputs as input signals.","Each label can consist of 62 characters in the set [a-z0-9-]. We convert a label to input signals by splitting the label into two strings of 31 characters. Each of these strings is then converted into a 248-bit string, then into an integer. The resulting integers are the input signals for the hashing function.","Users are able to register their names using only the hash. This the first of a number of privacy features which allows users to utilize the system without creating visible links of information on-chain."]},{"i":"what-are-input-signals","l":"What are Input Signals?","p":["The hashing algorithm that is used to hash the domains accepts only integer inputs. Any name consisting of n labels can be converted to a set of n * 2 input signals, which can then be used as inputs in our hashing algorithm.","Example: the name myname.mydomain.avax has 3 labels and can be converted to a set of 6 integers known as the Input Signals"]}],[{"i":"registration-privacy--revealing-a-name","l":"Registration Privacy & Revealing a Name","p":["Registrations can be made with Standard Privacy or Enhanced Privacy. At a technical level, a Standard Privacy registration means that a user published the preimage of their name to the chain while an Enhanced Privacy registration has not. That is the only difference.","We achieve this by publishing the Input Signals of a name to the Rainbow Table contract. This is known as Revealing a Name.","Any user can publish the Input Signals for a name as long as the signals correspond to the hash provided."]},{"l":"Finding the preimage of a hash","p":["Client applications can query the Rainbow Table with a hash. If the preimage hash been published to the Rainbow Table it will be returned in the Input Signal format. The client application can then decode the Input Signals into the ascii name.","We recommend using the provided client libraries to handle these tasks."]},{"l":"Zero Knowledge Proofs","p":["The system puts constraints on the names that can be registered in the system. As an example constraint, we only allow lowercase letters to be registered in names.","Since users are only required to submit a hash of the name on-chain, we use zero knowledge proofs to assert properties of the name without divulging details about the name.","Zero knowledge proofs are used to enforce system constraints and to determine pricing for names being registered."]}],[{"i":"records--record-types","l":"Records & Record Types","p":["A .avax domain is a type of database. Users can use the system to link pieces of information to their .avax name. We call these pieces of information Records.","A client of the system will usually have one of two goals:","Given a .avax name, let me find an associated Record","Given a Record, let me find the associated .avax name","These two operations are the core of our system. The operations are referred to as Forward Resolution and Reverse Resolution, respectively.","You can think of Avvy Domains as a key-value database, where the key is either a number or a string and the value is any string."]},{"l":"Record Types","p":["Avvy Domains supports two types of Records:","Standard Records are identified by a number & accompanied by a specification. A list of Standard Records is maintained in our Client Common library.","Custom Records are identified by a string & have no formal specification. Users of the system are free to define their own specifications or use the tool however they wish."]}],[{"l":"Forward Resolution","p":["Forward Resolution is the process of taking a .avax name and using it to retrieve a value, such as an 0x address for EVM chains. An important property of forward resolution is that many.avax names can resolve to the same value."]},{"i":"how-does-forward-resolution-work","l":"How does forward resolution work?","p":["Forward Resolution includes the use of two contracts:","The ResolverRegistry tracks which Resolver should be used to resolve values for a given name. Users can define custom Resolvers or use pre-built ones.","The Resolver responds to the actual query for the value.","Step 1. Find the address of the Resolver contract","To find the address of a Resolver contract for a name, we hash the name then call the get(uint256 name, uint256 hash) method on the ResolverRegistry.","It is possible that there is no entry for the name in the ResolverRegistry. If the name has two or less labels (e.g. myname.avax has two labels), forward resolution fails. If the name has three or more labels, the lowest tier label should be removed & the process should be repeated (e.g. for subdomain.domain.avax, we should repeat the process with domain.avax).","Step 2. Query the Resolver contract","If we have found an address for a Resolver contract, we can resolve a value as follows:","For custom records, call resolve(uint256 datasetId, uint256 hash, string memory key)","For standard records, call resolveStandard(uint256 datasetId, uint256 hash, uint256 key)","We recommend using our Client Libraries to perform forward resolution."]},{"l":"Security Notes","p":["There is absolutely no sanitization or authentication performed on the values set for forward resolution. Registrants of a .avax name have full control to set values; client applications of all kinds should treat these values as untrusted."]}],[{"l":"Reverse Resolution","p":["Reverse Resolution is the process of taking a standard value, such as an 0x address, and using it to retrieve an associated .avax name.","An important property of reverse resolution is that each unique value can only resolve to a single .avax name.","Reverse Resolution is only supported for Standard Record Types. Custom Records are not supported."]},{"i":"how-does-reverse-resolution-work","l":"How does reverse resolution work?","p":["Each type of value (e.g. EVM address, X-Chain address) requires a separate ReverseResolver contract. The ReverseResolverRegistry maintains pointers to the ReverseResolver contracts that should be used for each type of value.","After finding the relevant ReverseResolver address, that contract is used to fetch the value.","Step 1. Find the address of the ReverseResolver contract","Given a numbered Standard Record Type (e.g. 3 for EVM), call getResolver(uint256 standardKey) on the ReverseResolverRegistry.","Step 2. Query the ReverseResolver contract","Call get(target) on the ReverseResolver to return the associated hash.","We recommend using our Client Libraries to perform reverse resolution."]},{"l":"Authenticators","p":["The ReverseResolverRegistry handles permissioning for setting records on Reverse Resolvers. When a user attempts to set a reverse record, the Reverse Resolver will ask the Registry whether the user has permission to do so.","By default, the ReverseResolverRegistry will check whether the name is expired and whether the user is the current owner of the name. This default functionality can be overridden by deploying a custom authenticator contract & directing the ReverseResolverRegistry to use that custom authenticator contract for the name.","An Authenticator contract implements a single canWrite(..) method which returns a boolean value."]}],[{"l":"Subdomain Management","p":["The main registration system from Avvy Domains supports ownership of the root domain only.","For example, in the main system a user can register myname.avax but cannot register subdomain.myname.avax.","Management of subdomains such as subdomain.myname.avax is handled by Resolvers & Reverse Resolver contracts. The system has reasonable default settings and provides developers with a flexible interface for custom functionality."]},{"l":"Forward Resolution for Subdomains","p":["Forward Resolution for a name is handled by a Resolver contract. The Default Resolver allows the owner of a name to set records on that name or on any subdomain.","Developers can implement a custom Resolver contract to suit their needs. For example, a custom Resolver could implement the ERC721 spec, granting users ownership of subdomains & allowing owners to set records on the custom Resolver.","Custom Resolver contracts should implement the ResolverInterface"]},{"l":"Reverse Resolution","p":["Reverse Resolution for names are handled by Reverse Resolver contracts, which are deployed by the system. The ReverseResolverRegistry contract is responsible for authorizing transactions which set reverse records. The default authorization mechanism simply checks whether the domain registration is valid & whether the user is the owner of the root domain.","Developers can implement a custom authorization contract to determine whether a given 0x address is authorized to set a reverse record on a given subdomain. This can, for example, enable developers to implement custom subdomain registries.","Custom authorization contracts should implement the ReverseResolverAuthenticatorInterface."]},{"l":"Examples","p":["An example project which implements a custom subdomain registry is available here"]}],[{"l":"Overview"},{"l":"Source Code","p":["Our contract source code is available on Github"]},{"l":"Deployments","p":["Contract ABI & mainnet contract addresses are available in our Client Common repository"]},{"l":"Integration into Solidity projects","p":["Integrators can install & import contracts in their solidity project via the @avvy/contracts package on NPM."]}],[{"i":"events--indexing","l":"Events & Indexing","p":["Indexers of the project may need to watch event logs to recompile the state of the Avvy Domains system offline.","We recommend using our Indexer tool to compile an offline index of the Avvy Domains system."]},{"l":"Domain Events","p":["The Domain contract emits a number of events relating to registrations.","Avvy Domains also supports two sensitive operations relating to domain disputes. The following events would be emitted by the Domain contract should those sensitive operations be executed."]},{"l":"RainbowTable Events","p":["Domains can be registered with only a one-way hash of the name. If the user chooses to reveal the preimage of the name, they do so using the Rainbow Table contract.","Indexers can fetch the preimage of the revealed hash by calling lookup(uint256 hash) on the RainbowTable. This returns a set of Input Signals, which can then be decoded to reveal the ascii preimage."]},{"l":"Forward Resolution Events","p":["The ResolverRegistry contract keeps track of which Resolver contract should be used to resolve records on a given name.","A client library of the Avvy Domains system will then fetch data from the referenced resolver. See Forward Resolution for more specific details on how data retrieval occurs.","Resolver contracts implement the ResolverInterface and should emit the following events, though Avvy Domains has no control over their deployment and so we cannot guarantee compliance with the interface."]},{"l":"Reverse Resolution Events","p":["The ReverseResolverRegistry contract keeps track of which contracts are used for reverse resolution of records. See Reverse Resolution for more specific details on how data retrieval is performed.","Reverse Resolver contracts are maintained by the Avvy team. At the moment there is only one contract, for reversing an EVM address. In the future we hope to expand that support to other values such as validator Node IDs.","The EVMReverseResolver, which is configured for standard key 3, emits the following event:"]}],[{"l":"Client Libraries","p":["We offer Client Libraries in various languages to handle the complexities of interacting with the Avvy Domains smart contracts."]},{"l":"Libraries","p":["Language","Package","Javascript","@avvy/client(NPM)","If you need a library implemented in a specific language please reach out to us!"]},{"l":"Client Common","p":["The Client Libraries all rely on a Client Common project which provides common static files like smart contract addresses & ABI as well as a list of Standard Record Types."]}],[{"l":"Indexer","p":["The Avvy Domains Indexer is a project meant to build a local representation of the current state of Avvy Domains. This project can be a useful tool for integrators who wish to have some queryable offline version of the .avax system.","The Indexer is available on Github"]}]]